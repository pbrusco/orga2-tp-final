Lo que puede esperar:

- Crear imagen de disco para Bochs, de tipo FAT16 con las tareas precompiladas dentro
- Driver de disco ata (la info esta en wiki.osdev.org/ATA)
- Interprete de FAT16 (aca hay algo de info: wiki.osdev.org/FAT16)

Lo que necesariamente tenemos que hacer:

1) Para "cargar" una tarea (o comenzar a ejecutarla desde memoria principal), vamos a necesitar:
	- Saber cuanto espacio en memoria queda disponible
	- Darle al proceso:
		* Directorio y tablas de pagina propios (4k cada uno, o sea, arranca con 8k como minimo)
		* espacio de memoria donde se carga
		* una TSS que necesita obligatoriamente y al menos:
			a) EIP inicial
			b) CR3 (direccion del dir de paginas)
	- Agregar la tarea a la cola de tareas para ejecutarse
	
2) Necesitamos una estructura de tipo cola para ir haciendo el switch de tareas (la idea seria hacer un round robin). Podemos usar algo parecido a la forma de dar memoria a los procesos, pero para el kernel. Una especie de kmalloc, y usar esos punteros para hacer una estructura de cola. Para esto creo que solo es necesario el valor de la tss en cada posicion de la cola.
	- Deberiamos poder agregar/eliminar una tarea dado su numero de TSS en la GDT
	
3) Deberiamos poder eliminar una tarea, ya sea para FORZARLA o porque termino su rutina (Deberian ser 2 syscall distintas. La de "termino la rutina" seria como el "ret" de intel. Creo que con solo conocer el numero de TSS en la GDT alcanza para eliminar la tarea y todos sus datos y devolver al sistema el espacio de memoria que esta ocupa.)

4) Hay que ver lo de las syscall. Creo que necesitamos las siguientes
	- Levantar una tarea de disco (o despertar una que ya este memoria precargada, si es que no hacemos lo del disco)
	- Terminar una tarea forzosamente
	- Fin de tarea (tipo "ret")
	- Pedido de memoria para una tarea de usuario (malloc)
	- Desalojo de memoria para una tarea de usuario (free)

------------------------------------------

funciones/estructuras a realizar:
	Para el manejo de memoria de bajo nivel:
		- Una que nos indique cuanta memoria fisica disponible hay en el sistema
		- Una que nos diga cuanta memoria libre queda
		- Paginas disponibles/ocupadas (ya la tenemos casi, es el bitmap que habiamos pensado)
		- Una a la cual se le pida una pagina libre, y devuelva su dir fisica y actualice el bitmap poniendola como ocupada
		- Una que dada una dir fisica de una pagina, la libere dejando en 0 su contenido y y actualizando el bitmap
	Para el manejo de memoria de alto nivel:
		- malloc. Charlar para recordar como se hacia, y todo lo que hace falta, pero en lineas generales deberia hacer lo siguiente:
			* Se deberia fijar en la direccion base para el HEAP de memoria del proceso que la llama (habiamos dicho que sea 0XE7000000, esta en memoria.h ) si está o no disponible. 
				a) Si no esta, es que el proceso nunca pidió memoria, por lo que se deberia habilitar esa pagina e inicializar el HEAP de la forma que habiamos charlado. Si esta, seguir.
				b) Buscar un lugar en ese HEAP donde entre/quepa el pedido que se realizo y devolver un puntero a esa direccion
		- kalloc. Idem pero para el kernel, para poder hacer la cola de procesos para el round-robin.
		- free. Liberar un espacio antes requerido a traves del malloc o kalloc.
		
	Para las tareas:
		- Una funcion que cree una nueva entrada en la GDT para una TSS. Recibe una direccion base y devuelve el numero de entrada en la TSS que se ocupó.
		- Una funcion que elimine una entrada de TSS en la GDT. Recibe el numero de entrada a eliminar.
		- Funcion/es necesaria/s para la creación y manejo/remapeo de directorio y tablas de paginas.
		- Estuctura de tipo cola para el sistema y uso del procesador (round-robin) y sus funciones (agregar y eliminar una tarea)
		- Eliminar una tarea del sistema (tanto forzosamente como por fin correcto)
		
-----------------------------

Creo que esto seria todo. Me parece que lo mas conveniente seria hacer todo esto para lo que ya tenemos. Es decir, armar todo esto para que funcione con lo del tp. Por ejemplo, podriamos armar todo como lo del tp con las nuevas estructuras y funciones que hagamos, y tener en memoria cargadas las tareas de pintor y traductor. Y podriamos hacer que al apretar una tecla arranque el pintor, con otra que termine, otra para que arranque el traductor y otra para que termine el traductor. O sea, que al apretar "1" arranque el pintor. Esto significaria armar su TSS con las funciones que hagamos, su directorio y tablas de pagina y demas cosas que necesita para ejecutarse y finalmente agregarlo a la cola de ejecucion. Idem para el traductor, ponele con la tecla "2". y que con la "3" y "4" se elminen el pintor y traductor respectivamente. Con esto bastaria para probar todo lo que hicimos (faltaria el desalojo de una tarea porque finalizó correctamente, y no porque se la mató)

Luego habria que ver si podemos hacer nuestras propias tareas y que se ejecuten sin problemas (Aca quizas tengamos problemas para saber el EIP del comienzo de la tarea, pero se vera mas adelante) comenzando las tareas al igual que el pintor y traductor, es decir, ya pre cargadas en memoria cuando se compila el kernel.

Si todo esto va bien, entonces ya tenemos CASI todo hecho. Lo unico que faltaria (y que se nos va a complicar bastante creo yo) es hacer el driver del disco y leer fat16. Pero en caso de que veamos que es muy complicado, creo que podemos charlar con Furfaro y entregar sólo el resto. Total el scheduling seria dinamico, y con "infinitas" tareas (las que entren en memoria). Lo que seria estatico es el cargado de tareas, que seria a nivel compilacion de kernel. Pero bue, aprendimos en sistemas que a veces el "administrador" de la pc toma todas las tareas a realizar, las carga de a una en la cinta magnetica y las corre. Luego, si quiere ejecutar mas tareas, tiene que hacer un cambio de cinta o cargar en la cina las nuevas tareas... asi que seria alto kernel el que armamos!!! jajajajaja
